#pragma once
#include <string>
#include <vector>
#include <map>
#include "../common.hpp"

namespace misc {
	namespace asf {



		// GUID List
		// generated by powershell from CSV extracted from ASF_Specification.doc (v1.2, Revision 01.20.03 - December 2004)
		// powershell: $data = Import-CSV .\asf_guids.csv; $data | % { $g = "0x" + [System.BitConverter]::ToString([guid]::parse($_.Guid).ToByteArray()).Replace("-",",0x");"const unsigned char " + $_.Name + "[16] = {" + $g + "}; //" + $_.Guid } | Out-Clipboard
		const unsigned char ASF_Advanced_Content_Encryption_Object[16] = { 0x33,0x85,0x05,0x43,0x81,0x69,0xE6,0x49,0x9B,0x74,0xAD,0x12,0xCB,0x86,0xD5,0x8C }; //43058533-6981-49E6-9B74-AD12CB86D58C
		const unsigned char ASF_Advanced_Mutual_Exclusion_Object[16] = { 0xCF,0x49,0x86,0xA0,0x75,0x47,0x70,0x46,0x8A,0x16,0x6E,0x35,0x35,0x75,0x66,0xCD }; //A08649CF-4775-4670-8A16-6E35357566CD
		const unsigned char ASF_Audio_Media[16] = { 0x40,0x9E,0x69,0xF8,0x4D,0x5B,0xCF,0x11,0xA8,0xFD,0x00,0x80,0x5F,0x5C,0x44,0x2B }; //F8699E40-5B4D-11CF-A8FD-00805F5C442B
		const unsigned char ASF_Audio_Spread[16] = { 0x50,0xCD,0xC3,0xBF,0x8F,0x61,0xCF,0x11,0x8B,0xB2,0x00,0xAA,0x00,0xB4,0xE2,0x20 }; //BFC3CD50-618F-11CF-8BB2-00AA00B4E220
		const unsigned char ASF_Bandwidth_Sharing_Exclusive[16] = { 0xAA,0x60,0x60,0xAF,0x97,0x51,0xD2,0x11,0xB6,0xAF,0x00,0xC0,0x4F,0xD9,0x08,0xE9 }; //AF6060AA-5197-11D2-B6AF-00C04FD908E9
		const unsigned char ASF_Bandwidth_Sharing_Object[16] = { 0xE6,0x09,0x96,0xA6,0x7B,0x51,0xD2,0x11,0xB6,0xAF,0x00,0xC0,0x4F,0xD9,0x08,0xE9 }; //A69609E6-517B-11D2-B6AF-00C04FD908E9
		const unsigned char ASF_Bandwidth_Sharing_Partial[16] = { 0xAB,0x60,0x60,0xAF,0x97,0x51,0xD2,0x11,0xB6,0xAF,0x00,0xC0,0x4F,0xD9,0x08,0xE9 }; //AF6060AB-5197-11D2-B6AF-00C04FD908E9
		const unsigned char ASF_Binary_Media[16] = { 0xE2,0x65,0xFB,0x3A,0xEF,0x47,0xF2,0x40,0xAC,0x2C,0x70,0xA9,0x0D,0x71,0xD3,0x43 }; //3AFB65E2-47EF-40F2-AC2C-70A90D71D343
		const unsigned char ASF_Bitrate_Mutual_Exclusion_Object[16] = { 0xDC,0x29,0xE2,0xD6,0xDA,0x35,0xD1,0x11,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE }; //D6E229DC-35DA-11D1-9034-00A0C90349BE
		const unsigned char ASF_Codec_List_Object[16] = { 0x40,0x52,0xD1,0x86,0x1D,0x31,0xD0,0x11,0xA3,0xA4,0x00,0xA0,0xC9,0x03,0x48,0xF6 }; //86D15240-311D-11D0-A3A4-00A0C90348F6
		const unsigned char ASF_Command_Media[16] = { 0xC0,0xCF,0xDA,0x59,0xE6,0x59,0xD0,0x11,0xA3,0xAC,0x00,0xA0,0xC9,0x03,0x48,0xF6 }; //59DACFC0-59E6-11D0-A3AC-00A0C90348F6
		const unsigned char ASF_Compatibility_Object[16] = { 0x30,0x26,0xB2,0x75,0x8E,0x66,0xCF,0x11,0xA6,0xD9,0x00,0xAA,0x00,0x62,0xCE,0x6C }; //75B22630-668E-11CF-A6D9-00AA0062CE6C
		const unsigned char ASF_Content_Branding_Object[16] = { 0xFA,0xB3,0x11,0x22,0x23,0xBD,0xD2,0x11,0xB4,0xB7,0x00,0xA0,0xC9,0x55,0xFC,0x6E }; //2211B3FA-BD23-11D2-B4B7-00A0C955FC6E
		const unsigned char ASF_Content_Description_Object[16] = { 0x33,0x26,0xB2,0x75,0x8E,0x66,0xCF,0x11,0xA6,0xD9,0x00,0xAA,0x00,0x62,0xCE,0x6C }; //75B22633-668E-11CF-A6D9-00AA0062CE6C
		const unsigned char ASF_Content_Encryption_Object[16] = { 0xFB,0xB3,0x11,0x22,0x23,0xBD,0xD2,0x11,0xB4,0xB7,0x00,0xA0,0xC9,0x55,0xFC,0x6E }; //2211B3FB-BD23-11D2-B4B7-00A0C955FC6E
		const unsigned char ASF_Content_Encryption_System_Windows_Media_DRM_Network_Devices[16] = { 0xB6,0x9B,0x07,0x7A,0xA4,0xDA,0x12,0x4E,0xA5,0xCA,0x91,0xD3,0x8D,0xC1,0x1A,0x8D }; //7A079BB6-DAA4-4e12-A5CA-91D38DC11A8D
		const unsigned char ASF_Data_Object[16] = { 0x36,0x26,0xB2,0x75,0x8E,0x66,0xCF,0x11,0xA6,0xD9,0x00,0xAA,0x00,0x62,0xCE,0x6C }; //75B22636-668E-11CF-A6D9-00AA0062CE6C
		const unsigned char ASF_Degradable_JPEG_Media[16] = { 0xE0,0x7D,0x90,0x35,0x15,0xE4,0xCF,0x11,0xA9,0x17,0x00,0x80,0x5F,0x5C,0x44,0x2B }; //35907DE0-E415-11CF-A917-00805F5C442B
		const unsigned char ASF_Digital_Signature_Object[16] = { 0xFC,0xB3,0x11,0x22,0x23,0xBD,0xD2,0x11,0xB4,0xB7,0x00,0xA0,0xC9,0x55,0xFC,0x6E }; //2211B3FC-BD23-11D2-B4B7-00A0C955FC6E
		const unsigned char ASF_Error_Correction_Object[16] = { 0x35,0x26,0xB2,0x75,0x8E,0x66,0xCF,0x11,0xA6,0xD9,0x00,0xAA,0x00,0x62,0xCE,0x6C }; //75B22635-668E-11CF-A6D9-00AA0062CE6C
		const unsigned char ASF_Extended_Content_Description_Object[16] = { 0x40,0xA4,0xD0,0xD2,0x07,0xE3,0xD2,0x11,0x97,0xF0,0x00,0xA0,0xC9,0x5E,0xA8,0x50 }; //D2D0A440-E307-11D2-97F0-00A0C95EA850
		const unsigned char ASF_Extended_Content_Encryption_Object[16] = { 0x14,0xE6,0x8A,0x29,0x22,0x26,0x17,0x4C,0xB9,0x35,0xDA,0xE0,0x7E,0xE9,0x28,0x9C }; //298AE614-2622-4C17-B935-DAE07EE9289C
		const unsigned char ASF_Extended_Stream_Properties_Object[16] = { 0xCB,0xA5,0xE6,0x14,0x72,0xC6,0x32,0x43,0x83,0x99,0xA9,0x69,0x52,0x06,0x5B,0x5A }; //14E6A5CB-C672-4332-8399-A96952065B5A
		const unsigned char ASF_File_Properties_Object[16] = { 0xA1,0xDC,0xAB,0x8C,0x47,0xA9,0xCF,0x11,0x8E,0xE4,0x00,0xC0,0x0C,0x20,0x53,0x65 }; //8CABDCA1-A947-11CF-8EE4-00C00C205365
		const unsigned char ASF_File_Transfer_Media[16] = { 0x2C,0x22,0xBD,0x91,0x1C,0xF2,0x7A,0x49,0x8B,0x6D,0x5A,0xA8,0x6B,0xFC,0x01,0x85 }; //91BD222C-F21C-497A-8B6D-5AA86BFC0185
		const unsigned char ASF_Group_Mutual_Exclusion_Object[16] = { 0x40,0x5A,0x46,0xD1,0x79,0x5A,0x38,0x43,0xB7,0x1B,0xE3,0x6B,0x8F,0xD6,0xC2,0x49 }; //D1465A40-5A79-4338-B71B-E36B8FD6C249
		const unsigned char ASF_Header_Extension_Object[16] = { 0xB5,0x03,0xBF,0x5F,0x2E,0xA9,0xCF,0x11,0x8E,0xE3,0x00,0xC0,0x0C,0x20,0x53,0x65 }; //5FBF03B5-A92E-11CF-8EE3-00C00C205365
		const unsigned char ASF_Header_Object[16] = { 0x30,0x26,0xB2,0x75,0x8E,0x66,0xCF,0x11,0xA6,0xD9,0x00,0xAA,0x00,0x62,0xCE,0x6C }; //75B22630-668E-11CF-A6D9-00AA0062CE6C
		const unsigned char ASF_Index_Object[16] = { 0xD3,0x29,0xE2,0xD6,0xDA,0x35,0xD1,0x11,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE }; //D6E229D3-35DA-11D1-9034-00A0C90349BE
		const unsigned char ASF_Index_Parameters_Object[16] = { 0xDF,0x29,0xE2,0xD6,0xDA,0x35,0xD1,0x11,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE }; //D6E229DF-35DA-11D1-9034-00A0C90349BE
		const unsigned char ASF_JFIF_Media[16] = { 0x00,0xE1,0x1B,0xB6,0x4E,0x5B,0xCF,0x11,0xA8,0xFD,0x00,0x80,0x5F,0x5C,0x44,0x2B }; //B61BE100-5B4E-11CF-A8FD-00805F5C442B
		const unsigned char ASF_Language_List_Object[16] = { 0xA9,0x46,0x43,0x7C,0xE0,0xEF,0xFC,0x4B,0xB2,0x29,0x39,0x3E,0xDE,0x41,0x5C,0x85 }; //7C4346A9-EFE0-4BFC-B229-393EDE415C85
		const unsigned char ASF_Marker_Object[16] = { 0x01,0xCD,0x87,0xF4,0x51,0xA9,0xCF,0x11,0x8E,0xE6,0x00,0xC0,0x0C,0x20,0x53,0x65 }; //F487CD01-A951-11CF-8EE6-00C00C205365
		const unsigned char ASF_Media_Object_Index_Object[16] = { 0xF8,0x03,0xB1,0xFE,0xAD,0x12,0x64,0x4C,0x84,0x0F,0x2A,0x1D,0x2F,0x7A,0xD4,0x8C }; //FEB103F8-12AD-4C64-840F-2A1D2F7AD48C
		const unsigned char ASF_Media_Object_Index_Parameters_Object[16] = { 0xAD,0x3B,0x20,0x6B,0x11,0x3F,0xE4,0x48,0xAC,0xA8,0xD7,0x61,0x3D,0xE2,0xCF,0xA7 }; //6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7
		const unsigned char ASF_Metadata_Library_Object[16] = { 0x94,0x1C,0x23,0x44,0x98,0x94,0xD1,0x49,0xA1,0x41,0x1D,0x13,0x4E,0x45,0x70,0x54 }; //44231C94-9498-49D1-A141-1D134E457054
		const unsigned char ASF_Metadata_Object[16] = { 0xEA,0xCB,0xF8,0xC5,0xAF,0x5B,0x77,0x48,0x84,0x67,0xAA,0x8C,0x44,0xFA,0x4C,0xCA }; //C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA
		const unsigned char ASF_Mutex_Bitrate[16] = { 0x01,0x2A,0xE2,0xD6,0xDA,0x35,0xD1,0x11,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE }; //D6E22A01-35DA-11D1-9034-00A0C90349BE
		const unsigned char ASF_Mutex_Language[16] = { 0x00,0x2A,0xE2,0xD6,0xDA,0x35,0xD1,0x11,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE }; //D6E22A00-35DA-11D1-9034-00A0C90349BE
		const unsigned char ASF_Mutex_Unknown[16] = { 0x02,0x2A,0xE2,0xD6,0xDA,0x35,0xD1,0x11,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE }; //D6E22A02-35DA-11D1-9034-00A0C90349BE
		const unsigned char ASF_No_Error_Correction[16] = { 0x00,0x57,0xFB,0x20,0x55,0x5B,0xCF,0x11,0xA8,0xFD,0x00,0x80,0x5F,0x5C,0x44,0x2B }; //20FB5700-5B55-11CF-A8FD-00805F5C442B
		const unsigned char ASF_Padding_Object[16] = { 0x74,0xD4,0x06,0x18,0xDF,0xCA,0x09,0x45,0xA4,0xBA,0x9A,0xAB,0xCB,0x96,0xAA,0xE8 }; //1806D474-CADF-4509-A4BA-9AABCB96AAE8
		const unsigned char ASF_Payload_Extension_System_Content_Type[16] = { 0x20,0xDC,0x90,0xD5,0xBC,0x07,0x6C,0x43,0x9C,0xF7,0xF3,0xBB,0xFB,0xF1,0xA4,0xDC }; //D590DC20-07BC-436C-9CF7-F3BBFBF1A4DC
		const unsigned char ASF_Payload_Extension_System_Encryption_Sample_ID[16] = { 0x4E,0xB8,0x98,0x66,0xFA,0x0A,0x30,0x43,0xAE,0xB2,0x1C,0x0A,0x98,0xD7,0xA4,0x4D }; //6698B84E-0AFA-4330-AEB2-1C0A98D7A44D
		const unsigned char ASF_Payload_Extension_System_File_Name[16] = { 0x0E,0xEC,0x65,0xE1,0xED,0x19,0xD7,0x45,0xB4,0xA7,0x25,0xCB,0xD1,0xE2,0x8E,0x9B }; //E165EC0E-19ED-45D7-B4A7-25CBD1E28E9B
		const unsigned char ASF_Payload_Extension_System_Pixel_Aspect_Ratio[16] = { 0x54,0xE5,0x1E,0x1B,0xEA,0xF9,0xC8,0x4B,0x82,0x1A,0x37,0x6B,0x74,0xE4,0xC4,0xB8 }; //1B1EE554-F9EA-4BC8-821A-376B74E4C4B8
		const unsigned char ASF_Payload_Extension_System_Sample_Duration[16] = { 0x50,0x94,0xBD,0xC6,0x7F,0x86,0x07,0x49,0x83,0xA3,0xC7,0x79,0x21,0xB7,0x33,0xAD }; //C6BD9450-867F-4907-83A3-C77921B733AD
		const unsigned char ASF_Payload_Extension_System_Timecode[16] = { 0xEC,0x95,0x95,0x39,0x67,0x86,0x2D,0x4E,0x8F,0xDB,0x98,0x81,0x4C,0xE7,0x6C,0x1E }; //399595EC-8667-4E2D-8FDB-98814CE76C1E
		const unsigned char ASF_Reserved_1[16] = { 0x11,0xD2,0xD3,0xAB,0xBA,0xA9,0xCF,0x11,0x8E,0xE6,0x00,0xC0,0x0C,0x20,0x53,0x65 }; //ABD3D211-A9BA-11cf-8EE6-00C00C205365
		const unsigned char ASF_Reserved_2[16] = { 0x41,0x52,0xD1,0x86,0x1D,0x31,0xD0,0x11,0xA3,0xA4,0x00,0xA0,0xC9,0x03,0x48,0xF6 }; //86D15241-311D-11D0-A3A4-00A0C90348F6
		const unsigned char ASF_Reserved_3[16] = { 0xE3,0xCB,0x1A,0x4B,0x0B,0x10,0xD0,0x11,0xA3,0x9B,0x00,0xA0,0xC9,0x03,0x48,0xF6 }; //4B1ACBE3-100B-11D0-A39B-00A0C90348F6
		const unsigned char ASF_Reserved_4[16] = { 0x20,0xDB,0xFE,0x4C,0xF6,0x75,0xCF,0x11,0x9C,0x0F,0x00,0xA0,0xC9,0x03,0x49,0xCB }; //4CFEDB20-75F6-11CF-9C0F-00A0C90349CB
		const unsigned char ASF_Script_Command_Object[16] = { 0x30,0x1A,0xFB,0x1E,0x62,0x0B,0xD0,0x11,0xA3,0x9B,0x00,0xA0,0xC9,0x03,0x48,0xF6 }; //1EFB1A30-0B62-11D0-A39B-00A0C90348F6
		const unsigned char ASF_Simple_Index_Object[16] = { 0x90,0x08,0x00,0x33,0xB1,0xE5,0xCF,0x11,0x89,0xF4,0x00,0xA0,0xC9,0x03,0x49,0xCB }; //33000890-E5B1-11CF-89F4-00A0C90349CB
		const unsigned char ASF_Stream_Bitrate_Properties_Object[16] = { 0xCE,0x75,0xF8,0x7B,0x8D,0x46,0xD1,0x11,0x8D,0x82,0x00,0x60,0x97,0xC9,0xA2,0xB2 }; //7BF875CE-468D-11D1-8D82-006097C9A2B2
		const unsigned char ASF_Stream_Prioritization_Object[16] = { 0x5B,0xD1,0xFE,0xD4,0xD3,0x88,0x4F,0x45,0x81,0xF0,0xED,0x5C,0x45,0x99,0x9E,0x24 }; //D4FED15B-88D3-454F-81F0-ED5C45999E24
		const unsigned char ASF_Stream_Properties_Object[16] = { 0x91,0x07,0xDC,0xB7,0xB7,0xA9,0xCF,0x11,0x8E,0xE6,0x00,0xC0,0x0C,0x20,0x53,0x65 }; //B7DC0791-A9B7-11CF-8EE6-00C00C205365
		const unsigned char ASF_Timecode_Index_Object[16] = { 0xD0,0x3F,0xB7,0x3C,0x4A,0x0C,0x03,0x48,0x95,0x3D,0xED,0xF7,0xB6,0x22,0x8F,0x0C }; //3CB73FD0-0C4A-4803-953D-EDF7B6228F0C
		const unsigned char ASF_Timecode_Index_Parameters_Object[16] = { 0x6D,0x49,0x5E,0xF5,0x97,0x97,0x5D,0x4B,0x8C,0x8B,0x60,0x4D,0xFE,0x9B,0xFB,0x24 }; //F55E496D-9797-4B5D-8C8B-604DFE9BFB24
		const unsigned char ASF_Video_Media[16] = { 0xC0,0xEF,0x19,0xBC,0x4D,0x5B,0xCF,0x11,0xA8,0xFD,0x00,0x80,0x5F,0x5C,0x44,0x2B }; //BC19EFC0-5B4D-11CF-A8FD-00805F5C442B
		const unsigned char ASF_Web_Stream_Format[16] = { 0x13,0x6B,0x1E,0xDA,0x59,0x83,0x50,0x40,0xB3,0x98,0x38,0x8E,0x96,0x5B,0xF0,0x0C }; //DA1E6B13-8359-4050-B398-388E965BF00C
		const unsigned char ASF_Web_Stream_Media_Subtype[16] = { 0xD4,0x57,0x62,0x77,0x27,0xC6,0xCB,0x41,0x8F,0x81,0x7A,0xC7,0xFF,0x1C,0x40,0xCC }; //776257D4-C627-41CB-8F81-7AC7FF1C40CC



		// powershell: $data | % { $_.Name + "," } | Out-Clipboard
		enum class ASFType
		{
			Unknown,
			ASF_Advanced_Content_Encryption_Object,
			ASF_Advanced_Mutual_Exclusion_Object,
			ASF_Audio_Media,
			ASF_Audio_Spread,
			ASF_Bandwidth_Sharing_Exclusive,
			ASF_Bandwidth_Sharing_Object,
			ASF_Bandwidth_Sharing_Partial,
			ASF_Binary_Media,
			ASF_Bitrate_Mutual_Exclusion_Object,
			ASF_Codec_List_Object,
			ASF_Command_Media,
			ASF_Compatibility_Object,
			ASF_Content_Branding_Object,
			ASF_Content_Description_Object,
			ASF_Content_Encryption_Object,
			ASF_Content_Encryption_System_Windows_Media_DRM_Network_Devices,
			ASF_Data_Object,
			ASF_Degradable_JPEG_Media,
			ASF_Digital_Signature_Object,
			ASF_Error_Correction_Object,
			ASF_Extended_Content_Description_Object,
			ASF_Extended_Content_Encryption_Object,
			ASF_Extended_Stream_Properties_Object,
			ASF_File_Properties_Object,
			ASF_File_Transfer_Media,
			ASF_Group_Mutual_Exclusion_Object,
			ASF_Header_Extension_Object,
			ASF_Header_Object,
			ASF_Index_Object,
			ASF_Index_Parameters_Object,
			ASF_JFIF_Media,
			ASF_Language_List_Object,
			ASF_Marker_Object,
			ASF_Media_Object_Index_Object,
			ASF_Media_Object_Index_Parameters_Object,
			ASF_Metadata_Library_Object,
			ASF_Metadata_Object,
			ASF_Mutex_Bitrate,
			ASF_Mutex_Language,
			ASF_Mutex_Unknown,
			ASF_No_Error_Correction,
			ASF_Padding_Object,
			ASF_Payload_Extension_System_Content_Type,
			ASF_Payload_Extension_System_Encryption_Sample_ID,
			ASF_Payload_Extension_System_File_Name,
			ASF_Payload_Extension_System_Pixel_Aspect_Ratio,
			ASF_Payload_Extension_System_Sample_Duration,
			ASF_Payload_Extension_System_Timecode,
			ASF_Reserved_1,
			ASF_Reserved_2,
			ASF_Reserved_3,
			ASF_Reserved_4,
			ASF_Script_Command_Object,
			ASF_Simple_Index_Object,
			ASF_Stream_Bitrate_Properties_Object,
			ASF_Stream_Prioritization_Object,
			ASF_Stream_Properties_Object,
			ASF_Timecode_Index_Object,
			ASF_Timecode_Index_Parameters_Object,
			ASF_Video_Media,
			ASF_Web_Stream_Format,
			ASF_Web_Stream_Media_Subtype
		};
		
		// powershell: $data | % { "if (common::VerifyGuids(guid, " + $_.Name + ")) { return ASFType::" + $_.Name + ";}" } | Out-Clipboard
		ASFType ASFTypeFromGuid(unsigned char guid[16]) {
			if (common::VerifyGuids(guid, ASF_Header_Object)) { return ASFType::ASF_Header_Object; }
			if (common::VerifyGuids(guid, ASF_Data_Object)) { return ASFType::ASF_Data_Object; }
			if (common::VerifyGuids(guid, ASF_Simple_Index_Object)) { return ASFType::ASF_Simple_Index_Object; }
			if (common::VerifyGuids(guid, ASF_Index_Object)) { return ASFType::ASF_Index_Object; }
			if (common::VerifyGuids(guid, ASF_Media_Object_Index_Object)) { return ASFType::ASF_Media_Object_Index_Object; }
			if (common::VerifyGuids(guid, ASF_Timecode_Index_Object)) { return ASFType::ASF_Timecode_Index_Object; }

			if (common::VerifyGuids(guid, ASF_File_Properties_Object)) { return ASFType::ASF_File_Properties_Object; }
			if (common::VerifyGuids(guid, ASF_Header_Extension_Object)) { return ASFType::ASF_Header_Extension_Object; }
			if (common::VerifyGuids(guid, ASF_Stream_Properties_Object)) { return ASFType::ASF_Stream_Properties_Object; }
			if (common::VerifyGuids(guid, ASF_Codec_List_Object)) { return ASFType::ASF_Codec_List_Object; }
			if (common::VerifyGuids(guid, ASF_Script_Command_Object)) { return ASFType::ASF_Script_Command_Object; }
			if (common::VerifyGuids(guid, ASF_Marker_Object)) { return ASFType::ASF_Marker_Object; }
			if (common::VerifyGuids(guid, ASF_Bitrate_Mutual_Exclusion_Object)) { return ASFType::ASF_Bitrate_Mutual_Exclusion_Object; }
			if (common::VerifyGuids(guid, ASF_Error_Correction_Object)) { return ASFType::ASF_Error_Correction_Object; }
			if (common::VerifyGuids(guid, ASF_Content_Description_Object)) { return ASFType::ASF_Content_Description_Object; }
			if (common::VerifyGuids(guid, ASF_Extended_Content_Description_Object)) { return ASFType::ASF_Extended_Content_Description_Object; }
			if (common::VerifyGuids(guid, ASF_Content_Branding_Object)) { return ASFType::ASF_Content_Branding_Object; }
			if (common::VerifyGuids(guid, ASF_Stream_Bitrate_Properties_Object)) { return ASFType::ASF_Stream_Bitrate_Properties_Object; }
			if (common::VerifyGuids(guid, ASF_Content_Encryption_Object)) { return ASFType::ASF_Content_Encryption_Object; }
			if (common::VerifyGuids(guid, ASF_Extended_Content_Encryption_Object)) { return ASFType::ASF_Extended_Content_Encryption_Object; }
			if (common::VerifyGuids(guid, ASF_Digital_Signature_Object)) { return ASFType::ASF_Digital_Signature_Object; }
			if (common::VerifyGuids(guid, ASF_Padding_Object)) { return ASFType::ASF_Padding_Object; }

			if (common::VerifyGuids(guid, ASF_Advanced_Content_Encryption_Object)) { return ASFType::ASF_Advanced_Content_Encryption_Object; }
			if (common::VerifyGuids(guid, ASF_Advanced_Mutual_Exclusion_Object)) { return ASFType::ASF_Advanced_Mutual_Exclusion_Object; }
			if (common::VerifyGuids(guid, ASF_Audio_Media)) { return ASFType::ASF_Audio_Media; }
			if (common::VerifyGuids(guid, ASF_Audio_Spread)) { return ASFType::ASF_Audio_Spread; }
			if (common::VerifyGuids(guid, ASF_Bandwidth_Sharing_Exclusive)) { return ASFType::ASF_Bandwidth_Sharing_Exclusive; }
			if (common::VerifyGuids(guid, ASF_Bandwidth_Sharing_Object)) { return ASFType::ASF_Bandwidth_Sharing_Object; }
			if (common::VerifyGuids(guid, ASF_Bandwidth_Sharing_Partial)) { return ASFType::ASF_Bandwidth_Sharing_Partial; }
			if (common::VerifyGuids(guid, ASF_Binary_Media)) { return ASFType::ASF_Binary_Media; }
			if (common::VerifyGuids(guid, ASF_Command_Media)) { return ASFType::ASF_Command_Media; }
			if (common::VerifyGuids(guid, ASF_Compatibility_Object)) { return ASFType::ASF_Compatibility_Object; }
			if (common::VerifyGuids(guid, ASF_Content_Encryption_System_Windows_Media_DRM_Network_Devices)) { return ASFType::ASF_Content_Encryption_System_Windows_Media_DRM_Network_Devices; }
			if (common::VerifyGuids(guid, ASF_Degradable_JPEG_Media)) { return ASFType::ASF_Degradable_JPEG_Media; }
			if (common::VerifyGuids(guid, ASF_Extended_Stream_Properties_Object)) { return ASFType::ASF_Extended_Stream_Properties_Object; }
			if (common::VerifyGuids(guid, ASF_File_Transfer_Media)) { return ASFType::ASF_File_Transfer_Media; }
			if (common::VerifyGuids(guid, ASF_Group_Mutual_Exclusion_Object)) { return ASFType::ASF_Group_Mutual_Exclusion_Object; }
			if (common::VerifyGuids(guid, ASF_Index_Parameters_Object)) { return ASFType::ASF_Index_Parameters_Object; }
			if (common::VerifyGuids(guid, ASF_JFIF_Media)) { return ASFType::ASF_JFIF_Media; }
			if (common::VerifyGuids(guid, ASF_Language_List_Object)) { return ASFType::ASF_Language_List_Object; }
			if (common::VerifyGuids(guid, ASF_Media_Object_Index_Parameters_Object)) { return ASFType::ASF_Media_Object_Index_Parameters_Object; }
			if (common::VerifyGuids(guid, ASF_Metadata_Library_Object)) { return ASFType::ASF_Metadata_Library_Object; }
			if (common::VerifyGuids(guid, ASF_Metadata_Object)) { return ASFType::ASF_Metadata_Object; }
			if (common::VerifyGuids(guid, ASF_Mutex_Bitrate)) { return ASFType::ASF_Mutex_Bitrate; }
			if (common::VerifyGuids(guid, ASF_Mutex_Language)) { return ASFType::ASF_Mutex_Language; }
			if (common::VerifyGuids(guid, ASF_Mutex_Unknown)) { return ASFType::ASF_Mutex_Unknown; }
			if (common::VerifyGuids(guid, ASF_No_Error_Correction)) { return ASFType::ASF_No_Error_Correction; }
			if (common::VerifyGuids(guid, ASF_Payload_Extension_System_Content_Type)) { return ASFType::ASF_Payload_Extension_System_Content_Type; }
			if (common::VerifyGuids(guid, ASF_Payload_Extension_System_Encryption_Sample_ID)) { return ASFType::ASF_Payload_Extension_System_Encryption_Sample_ID; }
			if (common::VerifyGuids(guid, ASF_Payload_Extension_System_File_Name)) { return ASFType::ASF_Payload_Extension_System_File_Name; }
			if (common::VerifyGuids(guid, ASF_Payload_Extension_System_Pixel_Aspect_Ratio)) { return ASFType::ASF_Payload_Extension_System_Pixel_Aspect_Ratio; }
			if (common::VerifyGuids(guid, ASF_Payload_Extension_System_Sample_Duration)) { return ASFType::ASF_Payload_Extension_System_Sample_Duration; }
			if (common::VerifyGuids(guid, ASF_Payload_Extension_System_Timecode)) { return ASFType::ASF_Payload_Extension_System_Timecode; }
			if (common::VerifyGuids(guid, ASF_Reserved_1)) { return ASFType::ASF_Reserved_1; }
			if (common::VerifyGuids(guid, ASF_Reserved_2)) { return ASFType::ASF_Reserved_2; }
			if (common::VerifyGuids(guid, ASF_Reserved_3)) { return ASFType::ASF_Reserved_3; }
			if (common::VerifyGuids(guid, ASF_Reserved_4)) { return ASFType::ASF_Reserved_4; }
			if (common::VerifyGuids(guid, ASF_Stream_Prioritization_Object)) { return ASFType::ASF_Stream_Prioritization_Object; }
			if (common::VerifyGuids(guid, ASF_Timecode_Index_Parameters_Object)) { return ASFType::ASF_Timecode_Index_Parameters_Object; }
			if (common::VerifyGuids(guid, ASF_Video_Media)) { return ASFType::ASF_Video_Media; }
			if (common::VerifyGuids(guid, ASF_Web_Stream_Format)) { return ASFType::ASF_Web_Stream_Format; }
			if (common::VerifyGuids(guid, ASF_Web_Stream_Media_Subtype)) { return ASFType::ASF_Web_Stream_Media_Subtype; }
			return ASFType::Unknown;
		}
		
		// generated from powershell: $data | % { "if (type == ASFType::" + $_.Name + ") { return `"" + $_.Name + "`";}" } | Out-Clipboard
		std::string ASFTypeToString(ASFType type) {
			if (type == ASFType::ASF_Advanced_Content_Encryption_Object) { return "ASF_Advanced_Content_Encryption_Object"; }
			if (type == ASFType::ASF_Advanced_Mutual_Exclusion_Object) { return "ASF_Advanced_Mutual_Exclusion_Object"; }
			if (type == ASFType::ASF_Audio_Media) { return "ASF_Audio_Media"; }
			if (type == ASFType::ASF_Audio_Spread) { return "ASF_Audio_Spread"; }
			if (type == ASFType::ASF_Bandwidth_Sharing_Exclusive) { return "ASF_Bandwidth_Sharing_Exclusive"; }
			if (type == ASFType::ASF_Bandwidth_Sharing_Object) { return "ASF_Bandwidth_Sharing_Object"; }
			if (type == ASFType::ASF_Bandwidth_Sharing_Partial) { return "ASF_Bandwidth_Sharing_Partial"; }
			if (type == ASFType::ASF_Binary_Media) { return "ASF_Binary_Media"; }
			if (type == ASFType::ASF_Bitrate_Mutual_Exclusion_Object) { return "ASF_Bitrate_Mutual_Exclusion_Object"; }
			if (type == ASFType::ASF_Codec_List_Object) { return "ASF_Codec_List_Object"; }
			if (type == ASFType::ASF_Command_Media) { return "ASF_Command_Media"; }
			if (type == ASFType::ASF_Compatibility_Object) { return "ASF_Compatibility_Object"; }
			if (type == ASFType::ASF_Content_Branding_Object) { return "ASF_Content_Branding_Object"; }
			if (type == ASFType::ASF_Content_Description_Object) { return "ASF_Content_Description_Object"; }
			if (type == ASFType::ASF_Content_Encryption_Object) { return "ASF_Content_Encryption_Object"; }
			if (type == ASFType::ASF_Content_Encryption_System_Windows_Media_DRM_Network_Devices) { return "ASF_Content_Encryption_System_Windows_Media_DRM_Network_Devices"; }
			if (type == ASFType::ASF_Data_Object) { return "ASF_Data_Object"; }
			if (type == ASFType::ASF_Degradable_JPEG_Media) { return "ASF_Degradable_JPEG_Media"; }
			if (type == ASFType::ASF_Digital_Signature_Object) { return "ASF_Digital_Signature_Object"; }
			if (type == ASFType::ASF_Error_Correction_Object) { return "ASF_Error_Correction_Object"; }
			if (type == ASFType::ASF_Extended_Content_Description_Object) { return "ASF_Extended_Content_Description_Object"; }
			if (type == ASFType::ASF_Extended_Content_Encryption_Object) { return "ASF_Extended_Content_Encryption_Object"; }
			if (type == ASFType::ASF_Extended_Stream_Properties_Object) { return "ASF_Extended_Stream_Properties_Object"; }
			if (type == ASFType::ASF_File_Properties_Object) { return "ASF_File_Properties_Object"; }
			if (type == ASFType::ASF_File_Transfer_Media) { return "ASF_File_Transfer_Media"; }
			if (type == ASFType::ASF_Group_Mutual_Exclusion_Object) { return "ASF_Group_Mutual_Exclusion_Object"; }
			if (type == ASFType::ASF_Header_Extension_Object) { return "ASF_Header_Extension_Object"; }
			if (type == ASFType::ASF_Header_Object) { return "ASF_Header_Object"; }
			if (type == ASFType::ASF_Index_Object) { return "ASF_Index_Object"; }
			if (type == ASFType::ASF_Index_Parameters_Object) { return "ASF_Index_Parameters_Object"; }
			if (type == ASFType::ASF_JFIF_Media) { return "ASF_JFIF_Media"; }
			if (type == ASFType::ASF_Language_List_Object) { return "ASF_Language_List_Object"; }
			if (type == ASFType::ASF_Marker_Object) { return "ASF_Marker_Object"; }
			if (type == ASFType::ASF_Media_Object_Index_Object) { return "ASF_Media_Object_Index_Object"; }
			if (type == ASFType::ASF_Media_Object_Index_Parameters_Object) { return "ASF_Media_Object_Index_Parameters_Object"; }
			if (type == ASFType::ASF_Metadata_Library_Object) { return "ASF_Metadata_Library_Object"; }
			if (type == ASFType::ASF_Metadata_Object) { return "ASF_Metadata_Object"; }
			if (type == ASFType::ASF_Mutex_Bitrate) { return "ASF_Mutex_Bitrate"; }
			if (type == ASFType::ASF_Mutex_Language) { return "ASF_Mutex_Language"; }
			if (type == ASFType::ASF_Mutex_Unknown) { return "ASF_Mutex_Unknown"; }
			if (type == ASFType::ASF_No_Error_Correction) { return "ASF_No_Error_Correction"; }
			if (type == ASFType::ASF_Padding_Object) { return "ASF_Padding_Object"; }
			if (type == ASFType::ASF_Payload_Extension_System_Content_Type) { return "ASF_Payload_Extension_System_Content_Type"; }
			if (type == ASFType::ASF_Payload_Extension_System_Encryption_Sample_ID) { return "ASF_Payload_Extension_System_Encryption_Sample_ID"; }
			if (type == ASFType::ASF_Payload_Extension_System_File_Name) { return "ASF_Payload_Extension_System_File_Name"; }
			if (type == ASFType::ASF_Payload_Extension_System_Pixel_Aspect_Ratio) { return "ASF_Payload_Extension_System_Pixel_Aspect_Ratio"; }
			if (type == ASFType::ASF_Payload_Extension_System_Sample_Duration) { return "ASF_Payload_Extension_System_Sample_Duration"; }
			if (type == ASFType::ASF_Payload_Extension_System_Timecode) { return "ASF_Payload_Extension_System_Timecode"; }
			if (type == ASFType::ASF_Reserved_1) { return "ASF_Reserved_1"; }
			if (type == ASFType::ASF_Reserved_2) { return "ASF_Reserved_2"; }
			if (type == ASFType::ASF_Reserved_3) { return "ASF_Reserved_3"; }
			if (type == ASFType::ASF_Reserved_4) { return "ASF_Reserved_4"; }
			if (type == ASFType::ASF_Script_Command_Object) { return "ASF_Script_Command_Object"; }
			if (type == ASFType::ASF_Simple_Index_Object) { return "ASF_Simple_Index_Object"; }
			if (type == ASFType::ASF_Stream_Bitrate_Properties_Object) { return "ASF_Stream_Bitrate_Properties_Object"; }
			if (type == ASFType::ASF_Stream_Prioritization_Object) { return "ASF_Stream_Prioritization_Object"; }
			if (type == ASFType::ASF_Stream_Properties_Object) { return "ASF_Stream_Properties_Object"; }
			if (type == ASFType::ASF_Timecode_Index_Object) { return "ASF_Timecode_Index_Object"; }
			if (type == ASFType::ASF_Timecode_Index_Parameters_Object) { return "ASF_Timecode_Index_Parameters_Object"; }
			if (type == ASFType::ASF_Video_Media) { return "ASF_Video_Media"; }
			if (type == ASFType::ASF_Web_Stream_Format) { return "ASF_Web_Stream_Format"; }
			if (type == ASFType::ASF_Web_Stream_Media_Subtype) { return "ASF_Web_Stream_Media_Subtype"; }
			return "Unknown";
		}

		class asf_object  {
		public:
			ASFType type;
			std::vector<unsigned char> data;
			virtual std::string ToJson() const = 0;
			virtual std::string ToXml() const = 0;
		};
		asf_object* Parse(unsigned char* buffer, std::size_t max, unsigned int offset);

		class asf_unknown : public asf_object {
		public:
			asf_unknown(unsigned char guid[16], std::vector<unsigned char> data) {
				this->type = ASFTypeFromGuid(guid);
				this->data = data;
			}
			virtual std::string ToJson() const {
				std::ostringstream str;
				str << "{";
				str << "\"Type\":\"" << ASFTypeToString(this->type) << "\",";
				str << "\"Data\":\"" << common::bin2hex11(this->data) << "\"";
				str << "}";
				return str.str();
			}
			virtual std::string ToXml() const {
				std::ostringstream str;
				str << "<ASFObject>";
				str << "<Type>" << ASFTypeToString(this->type) << "</Type>";
				str << "<Data>" << common::bin2hex11(this->data) << "</Data>";
				str << "</ASFObject>";
				return str.str();
			}
		};
		class asf_header : public asf_object {		
		public:
			unsigned long long size;
			unsigned long number;
			unsigned char reserved1;
			unsigned char reserved2;
			asf_header(std::vector<unsigned char> data, unsigned long long totalSize) {
				this->type = ASFType::ASF_Header_Object;
				this->size = totalSize;
				this->number = common::ReadULong(data.data(),data.size(), 0);
				this->reserved1 = data[4];
				this->reserved2 = data[5];
			}
			virtual std::string ToJson() const {
				std::ostringstream str;
				str << "{";
				str << "\"Type\":\"" << ASFTypeToString(this->type) << "\",";
				str << "\"Number\":" << this->number << ",";
				str << "\"Alignment\":" <<  (int)this->reserved1;
				str << ",\"Architecture\":" << (int)this->reserved2;
				str << "}";
				return str.str();
			}
			virtual std::string ToXml() const {
				std::ostringstream str;
				str << "<ASFObject>";
				str << "<Type>" << ASFTypeToString(this->type) << "</Type>";
				str << "<Number>" << this->number << "</Number>";
				str << "<Alignment>" <<  (int) this->reserved1 << "</Alignment>";
				str << "<Architecture>" << (int) this->reserved2 << "</Architecture>";
				str << "</ASFObject>";
				return str.str();
			}
		};

		class file_properties : public asf_object {
		private:
			unsigned char file_id[16];
			unsigned long long file_size;
			unsigned long long creation;
			unsigned long long dp_count;
			unsigned long long play_duration;
			unsigned long long send_duration;
			unsigned long long preroll;
			unsigned long flags;
			unsigned long min_dp_size;
			unsigned long max_dp_size;
			unsigned long max_bitrate;
		public:
			file_properties(std::vector<unsigned char> data) {
				this->type = ASFType::ASF_File_Properties_Object;
				this->data = data;
				unsigned char* buffer = this->data.data();
				auto max = this->data.size();
				unsigned int index = 0;
				
				for (int i = 0; i < 16; i++) { this->file_id[i] = buffer[i + index]; }
				index += 16;

				this->file_size = common::ReadULongLong(buffer, max, index);
				index += 8;
				this->creation = common::ReadULongLong(buffer, max, index);
				index += 8;
				this->dp_count = common::ReadULongLong(buffer, max, index);
				index += 8;
				this->play_duration = common::ReadULongLong(buffer, max, index);
				index += 8;
				this->send_duration = common::ReadULongLong(buffer, max, index);
				index += 8;
				this->preroll = common::ReadULongLong(buffer, max, index);
				index += 8;
				this->flags = common::ReadULong(buffer, max, index);
				index += 4;
				this->min_dp_size = common::ReadULong(buffer, max, index);
				index += 4;
				this->max_dp_size = common::ReadULong(buffer, max, index);
				index += 4;
				this->max_bitrate = common::ReadULong(buffer, max, index);
				index += 4;
			}
			virtual std::string ToJson() const {
				std::ostringstream str;
				str << "{";
				str << "\"Type\":\"" << ASFTypeToString(this->type) << "\",";
				str << "\"file_id\":\"" << common::erasenulls(common::bin2hex11(this->file_id, 16)) << "\",";
				str << "\"file_size\":" << this->file_size << ",";
				str << "\"creation\":" << this->creation << ",";
				str << "\"dp_count\":" << this->dp_count << ",";
				str << "\"play_duration\":" << this->play_duration << ",";
				str << "\"send_duration\":" << this->send_duration << ",";
				str << "\"preroll\":" << this->preroll << ",";
				str << "\"flags\":" << this->flags << ",";
				str << "\"min_dp_size\":" << this->min_dp_size << ",";
				str << "\"max_dp_size\":" << this->max_dp_size << ",";
				str << "\"max_bitrate\":" << this->max_bitrate;
				str << "}";
				return str.str();
			}
			virtual std::string ToXml() const {
				std::ostringstream str;
				str << "<ASFObject>";
				str << "<Type>" << ASFTypeToString(this->type) << "</Type>";
				str << "<file_id>" << common::erasenulls(common::bin2hex11(this->file_id, 16)) << "</file_id>";
				str << "<file_size>" << this->file_size << "</file_size>";
				str << "<creation>" << this->creation << "</creation>";
				str << "<dp_count>" << this->dp_count << "</dp_count>";
				str << "<play_duration>" << this->play_duration << "</play_duration>";
				str << "<send_duration>" << this->send_duration << "</send_duration>";
				str << "<preroll>" << this->preroll << "</preroll>";
				str << "<flags>" << this->flags << "</flags>";
				str << "<min_dp_size>" << this->min_dp_size << "</min_dp_size>";
				str << "<max_dp_size>" << this->max_dp_size << "</max_dp_size>";
				str << "<max_bitrate>" << this->max_bitrate << "</max_bitrate>";
				str << "</ASFObject>";
				return str.str();
			}
		};

		class stream_properties_object : public asf_object {
		private:
			unsigned char stream_type[16];
			unsigned char error_correction_type[16];
			unsigned long long time_offset;
			unsigned long type_specific_data_length;
			unsigned long error_correction_data_length;
			unsigned int flags;
			unsigned long reserved;
			std::vector<unsigned char> type_specific_data;
			std::vector<unsigned char> error_correction_data;

			ASFType streamType;
			ASFType errCorrectionType;
		public:
			stream_properties_object(std::vector<unsigned char> data) {
				this->type = ASFType::ASF_Stream_Properties_Object;
				this->data = data;
				unsigned char* buffer = this->data.data();
				auto max = this->data.size();
				unsigned int index = 0;

				for (int i = 0; i < 16; i++) { this->stream_type[i] = buffer[i + index]; }
				index += 16;
				this->streamType = ASFTypeFromGuid(this->stream_type);

				for (int i = 0; i < 16; i++) { this->error_correction_type[i] = buffer[i + index]; }
				index += 16;
				this->errCorrectionType = ASFTypeFromGuid(this->error_correction_type);

				this->time_offset = common::ReadULongLong(buffer, max, index);
				index += 8;

				this->type_specific_data_length = common::ReadULong(buffer, max, index);
				index += 4;

				this->error_correction_data_length = common::ReadULong(buffer, max, index);
				index += 4;

				this->flags = common::ReadUShort(buffer, max, index);
				index += 2;

				this->reserved = common::ReadULong(buffer, max, index);
				index += 4;

				this->type_specific_data = common::readBuffer(buffer + index, this->type_specific_data_length);
				index += this->type_specific_data_length;

				this->error_correction_data = common::readBuffer(buffer + index, this->error_correction_data_length);
				index += this->error_correction_data_length;
			}
			virtual std::string ToJson() const {
				std::ostringstream str;
				str << "{";
				str << "\"Type\":\"" << ASFTypeToString(this->type) << "\",";
				str << "\"stream_type\":\"" << ASFTypeToString(this->streamType) << "\",";
				str << "\"error_correction_type\":\"" << ASFTypeToString(this->errCorrectionType) << "\",";
				str << "\"time_offset\":" << this->time_offset << ",";
				str << "\"type_specific_data_length\":" << this->type_specific_data_length << ",";
				str << "\"error_correction_data_length\":" << this->error_correction_data_length << ",";
				str << "\"flags\":" << this->flags << ",";
				str << "\"reserved\":" << this->reserved << ",";
				str << "\"type_specific_data\":\"" << common::bin2hex11(this->type_specific_data) << "\",";
				str << "\"error_correction_data\":\"" << common::bin2hex11(this->error_correction_data) << "\"";
				str << "}";
				return str.str();
			}
			virtual std::string ToXml() const {
				std::ostringstream str;
				str << "<ASFObject>";
				str << "<Type>" << ASFTypeToString(this->type) << "</Type>";
				str << "<stream_type>" << ASFTypeToString(this->streamType) << "</stream_type>";
				str << "<error_correction_type>" << ASFTypeToString(this->errCorrectionType) << "</error_correction_type>";
				str << "<time_offset>" << this->time_offset << "</time_offset>";
				str << "<type_specific_data_length>" << this->type_specific_data_length << "</type_specific_data_length>";
				str << "<error_correction_data_length>" << this->error_correction_data_length << "</error_correction_data_length>";
				str << "<flags>" << this->flags << "</flags>";
				str << "<reserved>" << this->reserved << "</reserved>";
				str << "<type_specific_data>" << common::bin2hex11(this->type_specific_data) << "</type_specific_data>";
				str << "<error_correction_data>" << common::bin2hex11(this->error_correction_data) << "</error_correction_data>";
				str << "</ASFObject>";
				return str.str();
			}
		};

		class header_extension_object : public asf_object {
		private:
			unsigned char reserved_field_1[16];
			unsigned int reserved_field_2;
			unsigned long header_extension_data_size;
			std::vector<unsigned char> header_extension_data;
			std::vector<asf_object*> children;
			ASFType clockType;
		public:
			header_extension_object(std::vector<unsigned char> data) {
				this->type = ASFType::ASF_Header_Extension_Object;
				this->data = data;
				auto buffer = this->data.data();
				auto max = this->data.size();
				unsigned int index = 0;

				for (int i = 0; i < 16; i++) { this->reserved_field_1[i] = buffer[i + index]; }
				index += 16;
				this->clockType = ASFTypeFromGuid(this->reserved_field_1);

				this->reserved_field_2 = common::ReadUShort(buffer, max, index);
				index += 2;

				this->header_extension_data_size = common::ReadULong(buffer, max, index);
				index += 4;

				this->header_extension_data = common::readBuffer(buffer + index, this->header_extension_data_size);
				index += this->header_extension_data_size;

				buffer = this->header_extension_data.data();
				max = this->header_extension_data.size();
				index = 0;
				while(index < this->header_extension_data_size) {
					asf_object* obj = Parse(buffer, max, index);
					if (obj != nullptr) {
						index += 24 + obj->data.size();
						this->children.push_back(obj);
					}

				}
			}

			virtual std::string ToJson() const {
				std::ostringstream str;
				str << "{";
				str << "\"Type\":\"" << ASFTypeToString(this->type) << "\",";
				str << "\"clock_type\":\"" << ASFTypeToString(this->clockType) << "\",";
				str << "\"clock_size\":\"" << this->reserved_field_2 << "\",";
				str << "\"header_extension_data_size\":\"" << this->header_extension_data_size << "\",";
				if (this->children.size() > 0) {
					str << "\"children\": [";
					for (std::vector<asf_object*>::const_iterator i = this->children.begin(); i != this->children.end(); i++) {
						if (i != this->children.begin()) str << ","; 
						str << (*i)->ToJson();
					}
					str << "]";
				}
				else {
					str << "\"header_extension_data\":\"" << common::bin2hex11(this->header_extension_data) << "\"";
				}

				str << "}";
				return str.str();
			}
			virtual std::string ToXml() const {
				std::ostringstream str;
				str << "<ASFObject>";
				str << "<Type>" << ASFTypeToString(this->type) << "</Type>";
				str << "<clock_type>" << ASFTypeToString(this->clockType) << "</clock_type>";
				str << "<clock_size>" << this->reserved_field_2 << "</clock_size>";
				str << "<header_extension_data_size>" << this->header_extension_data_size << "</header_extension_data_size>";
				if (this->children.size() > 0) {
					str << "<children>";
					for (std::vector<asf_object*>::const_iterator i = this->children.begin(); i != this->children.end(); i++) {
						str << (*i)->ToXml();
					}
					str << "</children>";
				}
				else {
					str << "<header_extension_data>" << common::bin2hex11(this->header_extension_data) << "</header_extension_data>";
				}

				str << "</ASFObject>";
				return str.str();
			}
		};

		class content_description_object : public asf_object {
		private:
			unsigned int title_length;
			unsigned int author_length;
			unsigned int copyright_length;
			unsigned int description_length;
			unsigned int rating_length;
			std::string title;
			std::string author;
			std::string copyright;
			std::string description;
			std::string rating;

		public:
			content_description_object(std::vector<unsigned char> data) {
				this->type = ASFType::ASF_Header_Extension_Object;
				this->data = data;
				unsigned char* buffer = this->data.data();
				auto max = this->data.size();
				unsigned int index = 0;

				this->title_length = common::ReadUShort(buffer, max, index);
				index += 2;

				this->author_length = common::ReadUShort(buffer, max, index);
				index += 2;

				this->copyright_length = common::ReadUShort(buffer, max, index);
				index += 2;

				this->description_length = common::ReadUShort(buffer, max, index);
				index += 2;

				this->rating_length = common::ReadUShort(buffer, max, index);
				index += 2;
				
				std::wstring tmptitle(reinterpret_cast<wchar_t const*>(buffer + index), this->title_length / 2);
				this->title = common::convert(tmptitle);
				index += this->title_length;

				std::wstring tmpauthor(reinterpret_cast<wchar_t const*>(buffer + index), this->author_length / 2);
				this->author = common::convert(tmpauthor);
				index += this->author_length;
				
				std::wstring tmpcopyright(reinterpret_cast<wchar_t const*>(buffer + index), this->copyright_length / 2);
				this->copyright = common::convert(tmpcopyright);
				index += this->copyright_length;
				
				std::wstring tmpdescription(reinterpret_cast<wchar_t const*>(buffer + index), this->description_length / 2);
				this->description = common::convert(tmpdescription);
				index += this->description_length;
				
				std::wstring tmprating(reinterpret_cast<wchar_t const*>(buffer + index), this->rating_length / 2);
				this->rating = common::convert(tmprating);
				index += this->rating_length;


			}
			virtual std::string ToJson() const {
				std::ostringstream str;
				str << "{";
				str << "\"Type\":\"" << ASFTypeToString(this->type) << "\",";
				str << "\"title\":\"" << this->title << "\",";
				str << "\"author\":\"" << this->author << "\",";
				str << "\"copyright\":\"" << this->copyright << "\",";
				str << "\"description\":\"" << this->description << "\",";
				str << "\"rating\":\"" << this->rating << "\"";
				str << "}";
				return str.str();
			}
			virtual std::string ToXml() const {
				std::ostringstream str;
				str << "<ASFObject>";
				str << "<Type>" << ASFTypeToString(this->type) << "</Type>";
				str << "<title>" << this->title << "</title>";
				str << "<author>" << this->author << "</author>";
				str << "<copyright>" << this->copyright << "</copyright>";
				str << "<description>" << this->description << "</description>";
				str << "<rating>" << this->rating << "</rating>";

				str << "<ASFObject>";
				return str.str();
			}
		};

		class content_descriptor {
		public:
			unsigned int totalSize;
			std::string Name;
			std::string Value;
			content_descriptor(unsigned char* buffer, std::size_t max, unsigned int offset) {
				unsigned int index = offset;

				unsigned short nameLength = common::ReadUShort(buffer, max, index);
				index += 2;

				std::wstring tmpName(reinterpret_cast<wchar_t const*>(buffer + index), nameLength / 2);
				this->Name = common::erasenulls(common::convert(tmpName));
				index += nameLength;

				unsigned short valueDataType = common::ReadUShort(buffer, max, index);
				index += 2;

				unsigned short valueDataLength = common::ReadUShort(buffer, max, index);
				index += 2;

				std::vector<unsigned char> valueData = common::readBuffer(buffer + index, valueDataLength);
				index += valueDataLength;

				switch (valueDataType)
				{
				case 0x0: //Unicode String
				{
					std::wstring tmp(reinterpret_cast<wchar_t const*>(valueData.data()), valueData.size() / 2);
					this->Value = common::erasenulls(common::convert(tmp));
					break;
				}
				case 0x1: //Byte array
					this->Value = common::bin2hex11(valueData);
					break;
				case 0x2: // BOOL
					this->Value = reinterpret_cast<bool>(valueData.data()) ? "true" : "false";
					break;
				case 0x3: // DWORD
					this->Value = std::to_string(reinterpret_cast<unsigned long>(valueData.data()));
					break;
				case 0x4: // QWORD
					this->Value = std::to_string(reinterpret_cast<unsigned int>(valueData.data()));
					break;
				case 0x5: // WORD
					this->Value = std::to_string(reinterpret_cast<unsigned short>(valueData.data()));
					break;
				}

				this->totalSize = index - offset;
			}
		};

		class extended_content_description_object : public asf_object {
		private:
			unsigned int content_descriptors_count;
			std::vector<content_descriptor*> content;
		public:
			extended_content_description_object(std::vector<unsigned char> data) {
				this->type = ASFType::ASF_Extended_Content_Description_Object;
				this->data = data;
				unsigned char* buffer = this->data.data();
				auto max = this->data.size();
				unsigned int index = 0;

				this->content_descriptors_count = common::ReadUShort(buffer, max, index);
				index += 2;

				for (unsigned int i = 0; i < this->content_descriptors_count; i++)
				{
					auto c = new content_descriptor(buffer, max, index);
					index += c->totalSize;
					this->content.push_back(c);
				}

			}
			virtual std::string ToJson() const {
				std::ostringstream str;
				str << "{";
				str << "\"Type\":\"" << ASFTypeToString(this->type) << "\",";
				str << "\"content_descriptors_count\":" << this->content_descriptors_count << ",";
				if (this->content.size() > 0) {
					str << "\"attributes\": {";
					for (std::vector<content_descriptor*>::const_iterator i = this->content.begin(); i != this->content.end(); i++) {
						if (i != this->content.begin()) str << ",";
						str << "\"" << common::trim((*i)->Name) << "\":\"" << common::trim((*i)->Value) << "\"";
					}
					str << "}";
				}

				str << "}";
				return str.str();
			}
			virtual std::string ToXml() const {
				std::ostringstream str;
				str << "<ASFObject>";
				str << "<Type>" << ASFTypeToString(this->type) << "</Type>";
				str << "<content_descriptors_count>" << this->content_descriptors_count << "</content_descriptors_count>";
				if (this->content.size() > 0) {
					str << "<attributes>";
					for (std::vector<content_descriptor*>::const_iterator i = this->content.begin(); i != this->content.end(); i++) {
						str << "<Name>" << common::trim((*i)->Name) << "</Name>";
						str << "<Value>" << common::trim((*i)->Value) << "</Value>";
					}
					str << "</attributes>";
				}
				str << "</ASFObject>";
				return str.str();
			}
		};

		class codec_entry {
		private:
		public:
			unsigned int totalSize;
			unsigned short type;
			std::string Name;
			std::string Description;
			std::vector<unsigned char> info;

			codec_entry(unsigned char* buffer, std::size_t max, unsigned int offset) {
				unsigned int index = offset;

				this->type = common::ReadUShort(buffer, max, index);
				index += 2;

				unsigned short nameLength = common::ReadUShort(buffer, max, index);
				index += 2;

				std::wstring tmpName(reinterpret_cast<wchar_t const*>(buffer + index), nameLength);				
				this->Name = common::erasenulls(common::convert(tmpName));
				index += nameLength * 2;

				unsigned short descLength = common::ReadUShort(buffer, max, index);
				index += 2;

				std::wstring tmpDesc(reinterpret_cast<wchar_t const*>(buffer + index), descLength);
				this->Description = common::erasenulls(common::convert(tmpDesc));
				index += descLength * 2;

				unsigned short infoLength = common::ReadUShort(buffer, max, index);
				index += 2;

				this->info = common::readBuffer(buffer + index, infoLength);
				index += infoLength;


				this->totalSize = index - offset;
			}

			std::string CodecTypeStr() {
				if (this->type == 0x1) { return "Video";}
				if (this->type == 0x2) { return "Audio";}
				if (this->type == 0xFFFF) { return "Unknown"; }
				return "Undefined";
			}
		};

		class codec_list_object : public asf_object {
		private:
			unsigned char reserved[16];
			unsigned long codec_entries_count;
			ASFType codec_id;
		public:
			std::vector<codec_entry*> codecs;

			codec_list_object(std::vector<unsigned char> data) {
				this->type = ASFType::ASF_Codec_List_Object;
				this->data = data;
				unsigned char* buffer = this->data.data();
				auto max = this->data.size();
				unsigned int index = 0;

				for (int i = 0; i < 16; i++) { this->reserved[i] = buffer[i + index]; }
				index += 16;
				this->codec_id = ASFTypeFromGuid(this->reserved);

				this->codec_entries_count = common::ReadULong(buffer, max, index);
				index += 4;

				for (unsigned int i = 0; i < this->codec_entries_count; i++)
				{
					auto c = new codec_entry(buffer, max, index);
					index += c->totalSize;
					this->codecs.push_back(c);
				}

			}
			virtual std::string ToJson() const {
				std::ostringstream str;
				str << "{";
				str << "\"Type\":\"" << ASFTypeToString(this->type) << "\",";
				str << "\"codec_id\":\"" << ASFTypeToString(this->codec_id) << "\",";
				str << "\"codec_entries_count\":\"" << this->codec_entries_count << "\",";
				if (this->codecs.size() > 0) {
					str << "\"codecs\": [";
					for (std::vector<codec_entry*>::const_iterator i = this->codecs.begin(); i != this->codecs.end(); i++) {
						if (i != this->codecs.begin()) str << ",";
						str << "{";
						str << "\"type\":\"" << (*i)->CodecTypeStr() << "\",";
						str << "\"name\":\"" << (*i)->Name << "\",";
						str << "\"description\":\"" << (*i)->Description << "\",";
						str << "\"info\":\"" << common::bin2hex11((*i)->info) << "\"";
						str << "}";
					}
					str << "]";
				}
				str << "}";
				return str.str();
			}
			virtual std::string ToXml() const {
				std::ostringstream str;
				str << "<ASFObject>";
				str << "<Type>" << ASFTypeToString(this->type) << "</Type>";
				str << "<codec_id>" << ASFTypeToString(this->codec_id) << "</codec_id>";
				str << "<codec_entries_count>" << this->codec_entries_count << "</codec_entries_count>";
				if (this->codecs.size() > 0) {
					str << "<codecs>";
					for (std::vector<codec_entry*>::const_iterator i = this->codecs.begin(); i != this->codecs.end(); i++) {
						str << "<codec>";
						str << "<type>" << (*i)->CodecTypeStr() << "</type>";
						str << "<name>" << (*i)->Name << "</name>";
						str << "<description>" << (*i)->Description << "</description>";
						str << "<info>" << common::bin2hex11((*i)->info) << "</info>";
						str << "</codec>";
					}
					str << "</codecs>";
				}
				str << "</ASFObject>";
				return str.str();
			}
		};





		asf_object* Parse(unsigned char* buffer, std::size_t max, unsigned int offset) {

			unsigned int index = offset;
			unsigned char guid[16];
			unsigned long long size;
			std::vector<unsigned char> data;

			if (index + 16 > max) {
				return nullptr;
			}

			for (int i = 0; i < 16; i++) { guid[i] = buffer[i + index]; }			
			index += 16;

			if (index + 8 > max) {
				return nullptr;
			}

			size = common::ReadULongLong(buffer, max, index);			
			index += 8;

			if (index + size - 24 > max) {
				return nullptr;
			}
			
			data = common::readBuffer(buffer + index, size - 24);

			asf_object* obj = nullptr;
			switch (ASFTypeFromGuid(guid)) {
			case ASFType::ASF_Header_Object:
				obj = new asf_header(data, size);
				break;
			case ASFType::ASF_File_Properties_Object:
				obj = new file_properties(data);
				break;
			case ASFType::ASF_Stream_Properties_Object:
				obj = new stream_properties_object(data);
				break;
			case ASFType::ASF_Header_Extension_Object:
				obj = new header_extension_object(data);
				break;
			case ASFType::ASF_Content_Description_Object:
				obj = new content_description_object(data);
				break;
			case ASFType::ASF_Extended_Content_Description_Object:
				obj = new extended_content_description_object(data);
				break;
			case ASFType::ASF_Codec_List_Object:
				obj = new codec_list_object(data);
				break;
			default:
				obj = new asf_unknown(guid, data);
				break;
			}
			return obj;
		}

		class ASFExtensionInfo : public common::ExtensionInfo {
		public:
			std::vector<asf_object*> headers;

			ASFExtensionInfo() {
			}
			virtual std::string ToJson() const override {
				std::ostringstream str;
				str << "{";
				str << "\"extension\" : \"" << this->Extension << "\"";
				str << ", \"name\" : \"" << this->VersionName << "\"";
				str << ", \"version\" : " << this->Version;

				if (this->headers.size() > 0) {
					str << ", \"headers\":[";
					for (std::vector<asf_object*>::const_iterator i = this->headers.begin(); i != this->headers.end(); i++) {
						if (i != this->headers.begin()) str << ",";
						str << (*i)->ToJson();
					}
					str << "]";
				}
				str << "}";
				return str.str();
			}
			virtual std::string ToXml() const override {
				std::ostringstream str;
				str << "<item>";
				str << "<extension>" << this->Extension << "</extension>";
				str << "<name>" << this->VersionName << "</name>";
				str << "<version>" << this->Version << "</version>";
				if (this->headers.size() > 0) {
					str << "<headers>";
					for (std::vector<asf_object*>::const_iterator i = this->headers.begin(); i != this->headers.end(); i++) {						
						str << (*i)->ToXml();
					}
					str << "</headers>";
				}
				str << "</item>";
				return str.str();
			}
			virtual std::string ToText() const override {
				std::ostringstream str;
				str << this->Extension;
				str << "\t" << this->VersionName;
				str << "\t" << this->Version;
				return str.str();
			}
			virtual std::string ToCsv() const override {
				std::ostringstream str;
				str << this->Extension;
				str << "," << this->VersionName;
				str << "," << this->Version;
				return str.str();
			}

		};

		std::vector<common::ExtensionInfo*> Detailer(std::string file, std::vector<unsigned char> buffer) {

			if (buffer.size() == STD_BUFFER_SIZE) {
				buffer = common::readFile(file, common::getFileSize(file));
			}

			std::vector<common::ExtensionInfo*> ans;
			ASFExtensionInfo* ei = new ASFExtensionInfo();
			ei->Extension = "asf";
			ei->Name = "Advanced Systems Format (ASF)";

			auto data = buffer.data();
			auto size = buffer.size();
			unsigned int index = 0;

			
			asf_header* header = (asf_header*) Parse(data, size, index);	
			if (header != nullptr) {
				index += 30;
				ei->headers.push_back(header);

				for (std::size_t i = 0; i < header->number && index < header->size; i++) {
					asf_object* obj = Parse(data, size, index);
					if (obj != nullptr) {
						index += 24 + obj->data.size();
						ei->headers.push_back(obj);

						if (obj->type == ASFType::ASF_Codec_List_Object) {
							codec_list_object* clo = (codec_list_object*)obj;

							if (clo->codecs.size() == 1) {
								codec_entry* codec = clo->codecs[0];
								if (codec->Name.rfind("Windows Media Audio", 0) == 0) {
									ei->Extension = "wma";
									ei->Name = "Windows Media Audio";
								}
							}
							else {
								for (std::vector<codec_entry*>::const_iterator it = clo->codecs.begin(); it != clo->codecs.end(); it++) {
									codec_entry* codec = (*it);
									if (codec->Name.rfind("Windows Media Video", 0) == 0) {
										ei->Extension = "wmv";
										ei->Name = "Windows Media Video";
									}

								}
							}
						}
					}
					else {
						break;
					}
				}
			}

			ans.push_back(ei);
			return ans;
		}
	}
}